import 'highlight.js/styles/github-dark.css';
import { FC } from 'react';

import Appendix from 'components/appendix';
import AuthorsNotes from 'components/authors_notes';
import Highlight from 'components/code';
import { Monospace } from 'components/copy';
import { PuzzleDataProps, getPuzzleProps } from 'components/puzzle';
import Solution, { Answerize, Clue } from 'components/solution';

const SLUG = 'the-10000-commit-git-repository';
const ANSWER = `ACDC`;

const PuzzleSolution: FC<PuzzleDataProps> = ({ puzzleData }) => (
  <Solution puzzleData={puzzleData} answer={ANSWER}>
    <p>
      We are given a zip that contains a git repository with 10,000 commits. As
      stated, the commits are all out of order -- in terms of both the ordinal
      in <Monospace>README.txt</Monospace>, and in the author / commit date
      (though these are consistent). Our task is to reorganize the commits,
      while keeping "everything" else the same.
    </p>
    <p>
      As described in this{' '}
      <a href="https://gist.github.com/masak/2415865">gist</a>, a commit hash is
      made up of the following information:
    </p>
    <ul>
      <li>Tree (files in the commit)</li>
      <li>Parent commit hash</li>
      <li>Authorship info</li>
      <li>Committer info (distinct from the author)</li>
      <li>Commit message</li>
    </ul>
    <p>
      As we're told in the puzzle, everything except the parent commit hash
      should stay the same.
    </p>
    <p>Then, our task is to:</p>
    <ol>
      <li>
        Extract the timestamp (and optionally file contents) for every commit in
        the randomized repo,
      </li>
      <li>
        Sort by timestamp and generate file contents if we didn't retrieve them,
      </li>
      <li>Create a series of 10000 custom commits in a fresh repo.</li>
    </ol>
    <p>
      For (1), we can use a command like
      <br />
      <Monospace>
        git log --pretty=format:%H,%ai &gt; git_commit_info.csv
      </Monospace>
      <br />
      to get the full hash and timestamp of every commit. We could then use the
      hash to get the file content at each commit, but this is unnecessary --
      the file content is accurate for each commit (for example, the
      chronologically first commit has the contents "This is the README in the
      1st commit.").
    </p>
    <p>
      The resulting repo has a HEAD commit hash of{' '}
      <span className="font-mono break-words">
        acdc008563621fcaa38e9ee9fa12543916efb954
      </span>
      . Since we're given the last 6 hex digits as a check, we should look at
      the first 6 hex digits. We see <Monospace>acdc</Monospace>, followed by a
      null byte, then garbage. The answer is <Answerize>{ANSWER}</Answerize>.
    </p>
    <AuthorsNotes>
      <p>Git was the real puzzle all along.</p>
    </AuthorsNotes>
    <Appendix>
      <p>
        Given a CSV containing commit hashes and ISO timestamps, as generated by
        the log command above, this Python script uses{' '}
        <a href="https://gitpython.readthedocs.io/en/stable/index.html">
          GitPython
        </a>{' '}
        to generate the repository. It ignores the commit hashes and just
        generates the contents based on the sorted order. Note that this library
        requires a manual newline in the commit message (which is implicitly
        added by the command line).
      </p>
      <Highlight lang="py" className="overflow-x-auto whitespace-pre">
        {`import csv
import datetime
import shutil
from pathlib import Path

from git import Actor, Repo

def ordinal(n: int):
  if 11 <= (n % 100) <= 13:
    suffix = "th"
  else:
    suffix = ["th", "st", "nd", "rd", "th"][min(n % 10, 4)]
  return str(n) + suffix

repo_path = Path("check-repo")
target_file = repo_path / "README.txt"
if repo_path.is_dir():
  shutil.rmtree(repo_path)
repo_path.mkdir()

repo = Repo.init(repo_path)
msg = "commit\\n"

author = Actor(name="Ben Bitdiddle", email="")
rows = []

with open("git_commit_info.csv") as f:
  reader = csv.reader(f)
  for row in reader:
    contents = row[0]
    date = datetime.datetime.fromisoformat(row[1])
    rows.append((contents, date))

rows.sort(key=lambda x: x[1])
for i, (_, date) in enumerate(rows):
  contents = f"This is the README in the {ordinal(i+1)} commit."
  with open(target_file, "w") as f2:
      f2.write(contents)
  repo.index.add(str(target_file.absolute()))
  repo.index.commit(
    message=msg,
    author=author,
    committer=author,
    commit_date=date,
    author_date=date,
  )`}
      </Highlight>
    </Appendix>
    {/* TODO: uncomment if you wish to include your own styles.
      <style jsx>{`
        .example {
          color: var(--dark);
        }
      `}</style>
        */}
  </Solution>
);

export default PuzzleSolution;
export const getServerSideProps = getPuzzleProps(SLUG);
